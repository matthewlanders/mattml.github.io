<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta name="generator" content="jemdoc, see http://jemdoc.jaboc.net/" />
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<link rel="stylesheet" href="jemdoc.css" type="text/css" />
<title>Twin Delayed Deep Deterministic Policy Gradients (TD3)</title>
<!-- MathJax -->
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async>
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
	  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<!-- End MathJax -->
<table summary="Table for page layout." id="tlayout">
<tr valign="top">
<td id="layout-menu">
<div class="menu-category">Matthew Landers</div>
<div class="menu-item"><a href="index.html">Home</a></div>
<div class="menu-item"><a href="industry-experience.html">Experience</a></div>
<div class="menu-item"><a href="static/Matthew_Landers_CV.pdf" target="blank">CV</a></div>
<div class="menu-category">Notes</div>
<div class="menu-item"><a href="about.html"><i>About&nbsp;these&nbsp;notes</i></a></div>
<div class="menu-item"><a href="glossary.html">Glossary</a></div>
<div class="menu-item"><a href="pseudocode.html">Pseudocode</a></div>
<div class="menu-item"><a href="about-rl.html">About&nbsp;RL</a></div>
<div class="menu-item"><a href="mdp.html">MDPs</a></div>
<div class="menu-item"><a href="value-functions-and-policies.html">Value&nbsp;Func.&nbsp;&amp;&nbsp;Policies</a></div>
<div class="menu-item"><a href="dynamic-programming-for-mdps.html">DP&nbsp;for&nbsp;MDPs</a></div>
<div class="menu-item"><a href="policy-and-value-iteration-proofs.html">DP&nbsp;for&nbsp;MDPs&nbsp;Proofs</a></div>
<div class="menu-item"><a href="model-free-prediction.html">Model-Free&nbsp;Prediction</a></div>
<div class="menu-item"><a href="prediction-with-function-approximation.html">Prediction&nbsp;with&nbsp;Approx.</a></div>
<div class="menu-item"><a href="model-free-control.html">Model-Free&nbsp;Control</a></div>
<div class="menu-item"><a href="on-policy-control-with-function-approximation.html">On-Policy&nbsp;Control<br /> with&nbsp;Approximation</a></div>
<div class="menu-item"><a href="off-policy-control-with-function-approximation.html">Off-Policy&nbsp;Control<br /> with&nbsp;Approximation</a></div>
<div class="menu-item"><a href="importance-sampling.html">Importance&nbsp;Sampling</a></div>
<div class="menu-item"><a href="learnability-of-rl-objectives.html">Learnability&nbsp;of<br /> RL&nbsp;Objectives</a></div>
<div class="menu-item"><a href="the-deadly-triad.html">The&nbsp;Deadly&nbsp;Triad</a></div>
<div class="menu-item"><a href="deep-q-learning.html">Deep&nbsp;Q-Learning</a></div>
<div class="menu-item"><a href="policy-gradients.html">Policy&nbsp;Gradients</a></div>
<div class="menu-item"><a href="actor-critic.html">Actor-Critic&nbsp;Framework</a></div>
<div class="menu-item"><a href="ddpg.html">DPG&nbsp;&amp;&nbsp;DDPG</a></div>
<div class="menu-item"><a href="reparameterization-trick.html">Reparameterization&nbsp;Trick</a></div>
<div class="menu-item"><a href="sac.html">Soft&nbsp;Actor-Critic</a></div>
<div class="menu-item"><a href="grpo.html">Group&nbsp;Relative&nbsp;Policy<br /> Optimization</a></div>
<div class="menu-item"><a href="transformer.html">Transformer</a></div>
<div class="menu-item"><a href="trpo.html">TRPO</a></div>
<div class="menu-item"><a href="conjugate-gradient-method.html">Conjugate&nbsp;Gradient&nbsp;Method</a></div>
<div class="menu-item"><a href="ppo.html">PPO</a></div>
<div class="menu-item"><a href="double-q-learning.html">Double&nbsp;Q-Learning</a></div>
<div class="menu-item"><a href="td3.html" class="current">TD3</a></div>
<div class="menu-item"><a href="nn-verification.html">NN&nbsp;Verification</a></div>
<div class="menu-item"><a href="drl-verification.html">DRL&nbsp;Verification</a></div>
<div class="menu-item"><a href="alphazero.html">AlphaZero&nbsp;(chess)</a></div>
<div class="menu-item"><a href="bayes-theorem-for-probability-distributions.html">Bayes&rsquo;&nbsp;for&nbsp;Distributions</a></div>
<div class="menu-item"><a href="backpropagation.html">Backpropagation</a></div>
<div class="menu-item"><a href="off-policy-evaluation.html">Off-Policy&nbsp;Evaluation</a></div>
<div class="menu-item"><a href="constrained-mdps.html">Constrained&nbsp;MDPs</a></div>
<div class="menu-item"><a href="cpo.html">Constrained&nbsp;Policy&nbsp;<br />Optimization</a></div>
<div class="menu-item"><a href="pid-lagrangian.html">PID&nbsp;Lagrangian</a></div>
<div class="menu-item"><a href="successor-features.html">Successor&nbsp;Features</a></div>
<div class="menu-item"><a href="policy-distillation.html">Policy&nbsp;Distillation</a></div>
<div class="menu-item"><a href="kl-divergence.html">KL&nbsp;Divergence</a></div>
<div class="menu-item"><a href="implicit-q-learning.html">Implicit&nbsp;Q-Learning</a></div>
</td>
<td id="layout-content">
<div id="toptitle">
<h1>Twin Delayed Deep Deterministic Policy Gradients (TD3)</h1>
</div>
<p><i>Revised June 19, 2025</i>
</p>
<p><i>The <a href="double-q-learning.html" target=&ldquo;blank&rdquo;>Double Q-learning</a> and <a href="ddpg.html" target=&ldquo;blank&rdquo;>DDPG</a> notes are optional but recommended background reading.</i>
</p>
<p>In Q-learning, <a href="double-q-learning.html" target=&ldquo;blank&rdquo;>overestimation arises</a> from the use of the \(\max\) operator during bootstrapping — among multiple noisy estimates, the maximum is selected, introducing positive bias into the target. Although <a href="ddpg.html" target=&ldquo;blank&rdquo;>deterministic policy gradient (DPG)</a> methods avoid discrete maximization, they remain susceptible to overestimation due to the interaction between the actor and an approximate critic.
</p>
<p>Let \(\pi(s;\phi)\) denote a deterministic policy parameterized by \(\phi\), and let \(Q(s,a;\theta)\) be an approximate critic. In DDPG, the actor is optimized by maximizing the critic's evaluation of its proposed actions, according to the objective:
</p>
<p style="text-align:center">
\[
\begin{equation}\label{eq:actor-objective}
    J(\phi) = \mathbb{E}_{s \sim \mathcal{D}} \left[ Q(s, \pi(s;\phi); \theta) \right] \;,
\end{equation}
\]
</p><p>where \(\mathcal{D}\) denotes the state distribution, typically sampled from a <a href="glossary.html" target=&ldquo;blank&rdquo;>replay buffer</a>.
</p>
<p>Let \(\phi_k\) be the actor parameters at iteration \(k\). Define \(\phi_\text{approx}\) as the updated parameters obtained by ascending the critic-derived objective in Equation \(\eqref{eq:actor-objective}\):
</p>
<p style="text-align:center">
\[
\begin{equation*}
    \phi_\text{approx} = \phi_k + \frac{\alpha_k}{Z_1} \left. \nabla_\phi \mathbb{E}_{s \sim \mathcal{D}} \left[ Q(s, \pi(s;\phi); \theta) \right] \right|_{\phi = \phi_k} \;,
\end{equation*}
\]
</p><p>where \(\alpha_k &gt; 0\) is the step size and \(Z_1 = \left. \nabla_\phi \mathbb{E}[\dots] \right|_{\phi_k}\) is the norm of the gradient, which serves as a normalization constant. The normalization term ensures that the update corresponds to a step of fixed length \(\alpha_k\) in the gradient direction. This scaling isolates the directional component of the update, simplifying comparison between updates derived from different objective functions. 
</p>
<p>Define \(\phi_\text{true}\) as the hypothetical update computed using the true action-value function \(Q(s,a)\):
</p>
<p style="text-align:center">
\[
\begin{equation*}
    \phi_\text{true} = \phi_k + \frac{\alpha_k}{Z_2} \left. \nabla_\phi \mathbb{E}_{s \sim \mathcal{D}} \left[ Q(s, \pi(s;\phi)) \right] \right|_{\phi = \phi_k} \;.
\end{equation*}
\]
</p><p>Since \(\phi_\text{approx}\) results from a step of length \(\alpha_k\) in the normalized gradient direction of the critic-derived objective \(J(\phi) = \mathbb{E}_{s \sim \mathcal{D}} \left[ Q(s, \pi(s;\phi); \theta) \right]\), it corresponds to the direction of steepest ascent under the critic's approximation. For sufficiently small \(\alpha_k\), this guarantees that the critic's evaluation of \(\pi(s;\phi_\text{approx})\) is at least as high as its evaluation of \(\pi(s;\phi_\text{true})\), which follows from a step of equal length in a generally different direction:
</p>
<p style="text-align:center">
\[
\begin{equation}\label{eq:ddpg-bound1}
    \mathbb{E}_{s \sim \mathcal{D}} \left[ Q(s, \pi(s;\phi_\text{approx}); \theta) \right] \geq \mathbb{E}_{s \sim \mathcal{D}} \left[ Q(s, \pi(s;\phi_\text{true}); \theta) \right] \;.
\end{equation}
\]
</p><p>Analogously, since \(\phi_\text{true}\) results from a step of length \(\alpha_k\) in the normalized gradient direction of the true objective \(J_\text{true}(\phi) = \mathbb{E}_{s \sim \mathcal{D}} \left[ Q(s, \pi(s;\phi)) \right]\), it defines the steepest local ascent under the true action-value. For sufficiently small \(\alpha_k\), this implies that the true value of \(\pi(s;\phi_\text{true})\) is at least as high as that of \(\pi(s;\phi_\text{approx})\):
</p>
<p style="text-align:center">
\[
\begin{equation}\label{eq:ddpg-bound2}
    \mathbb{E}_{s \sim \mathcal{D}} \left[ Q(s, \pi(s;\phi_\text{true})) \right] \geq \mathbb{E}_{s \sim \mathcal{D}} \left[ Q(s, \pi(s;\phi_\text{approx})) \right] \;.
\end{equation}
\]
</p><p>Suppose further that the critic overestimates the value of the action proposed by \(\phi_\text{true}\):
</p>
<p style="text-align:center">
\[
\begin{equation}\label{eq:ddpg-assumption}
    \mathbb{E}_{s \sim \mathcal{D}} \left[ Q(s, \pi(s;\phi_\text{true}); \theta) \right] \geq \mathbb{E}_{s \sim \mathcal{D}} \left[ Q(s, \pi(s;\phi_\text{true})) \right] \;.
\end{equation}
\]
</p><p>This assumption reflects a systematic upward bias in the critic's evaluation of near-optimal actions. This mirrors the <a href="double-q-learning.html" target=&ldquo;blank&rdquo;>overestimation phenomenon in Q-learning</a>, where the \(\max\) operator selects overestimated values. Although no explicit maximization occurs in DPG methods, the actor is explicitly optimized to increase \(Q(s, \pi(s;\phi); \theta)\), which biases the policy toward actions assigned high value by the critic. If \(Q(s,a;\theta)\) overestimates near the true optimum, gradient ascent amplifies this error, inducing bias through optimization rather than selection — precisely the condition assumed in Equation \(\eqref{eq:ddpg-assumption}\).
</p>
<p>Combining Equations \(\eqref{eq:ddpg-bound1}\)–\(\eqref{eq:ddpg-assumption}\) yields:
</p>
<p style="text-align:center">
\[
\begin{align}
    \mathbb{E}_{s \sim \mathcal{D}} \left[ Q(s, \pi(s;\phi_\text{approx}); \theta) \right]
    &amp;\geq \mathbb{E}_{s \sim \mathcal{D}} \left[ Q(s, \pi(s;\phi_\text{true}); \theta) \right] &amp;&amp; \text{by Equation \eqref{eq:ddpg-bound1}} \nonumber \\
    &amp;\geq \mathbb{E}_{s \sim \mathcal{D}} \left[ Q(s, \pi(s;\phi_\text{true})) \right] &amp;&amp; \text{by Equation \eqref{eq:ddpg-assumption}} \nonumber \\
    &amp;\geq \mathbb{E}_{s \sim \mathcal{D}} \left[ Q(s, \pi(s;\phi_\text{approx})) \right] &amp;&amp; \text{by Equation \eqref{eq:ddpg-bound2}} \;. \label{eq:ddpg-overestimation}
\end{align}
\]
</p><p>Thereby demonstrating that the critic overestimates the value of the updated policy. If such overestimation persists across iterations, the actor may converge toward regions of the action space that appear high-valued under the critic but yield suboptimal returns.
</p>
<div class="infoblock">
<div class="blockcontent">
<p><b>Proving the Local Improvement in Actor Objectives</b>
</p>
<p>To formalize the intuition behind Equations \(\eqref{eq:ddpg-bound1}\) and \(\eqref{eq:ddpg-bound2}\), we consider the first-order behavior of the critic-derived and true policy objectives under normalized gradient updates. Let
</p>
<p style="text-align:center">
\[
\begin{equation*}
    J_\theta(\phi) = \mathbb{E}_{s \sim \mathcal{D}} \left[ Q(s, \pi(s;\phi); \theta) \right] \quad \text{and} \quad J_\text{true}(\phi) = \mathbb{E}_{s \sim \mathcal{D}} \left[ Q(s, \pi(s;\phi)) \right]
\end{equation*}
\]
</p><p>denote the approximate and true policy evaluation objectives, respectively. Let \(\phi_k\) denote the current actor parameters, and define the gradient directions as:
</p>
<p style="text-align:center">
\[
\begin{equation*}
    g_\theta = \left. \nabla_\phi J_\theta(\phi) \right|_{\phi_k}, \qquad g_\text{true} = \left. \nabla_\phi J_\text{true}(\phi) \right|_{\phi_k} \;.
\end{equation*}
\]
</p><p>Let 
</p>
<p style="text-align:center">
\[
\begin{equation}\label{eq:norm-definitions}
    Z_1 = \|g_\theta\| \quad \text{and} \quad Z_2 = \|g_\text{true}\|
\end{equation}
\]
</p><p>denote the norms of these gradients. Then the update directions used to define \(\phi_\text{approx}\) and \(\phi_\text{true}\) are given by:
</p>
<p style="text-align:center">
\[
\begin{equation*}
    \phi_\text{approx} = \phi_k + \alpha_k \frac{g_\theta}{Z_1}, \qquad \phi_\text{true} = \phi_k + \alpha_k \frac{g_\text{true}}{Z_2} \;,
\end{equation*}
\]
</p><p>where \(\alpha_k &gt; 0\) is a small step size. Performing a first-order <a href="glossary.html" target=&ldquo;blank&rdquo;>Taylor expansion</a> of \(J_\theta\) around \(\phi_k\) gives
</p>
<p style="text-align:center">
\[
\begin{align*}
    J_\theta(\phi_\text{approx}) &amp;\approx J_\theta(\phi_k) + \alpha_k g_\theta^\top \frac{g_\theta}{Z_1} = J_\theta(\phi_k) + \alpha_k Z_1 \;, \\
    J_\theta(\phi_\text{true}) &amp;\approx J_\theta(\phi_k) + \alpha_k g_\theta^\top \frac{g_\text{true}}{Z_2} \;.
\end{align*}
\]
</p><p>It follows that:
</p>
<p style="text-align:center">
\[
\begin{equation}\label{eq:ddpg-bound1-derivation}
    J_\theta(\phi_\text{approx}) - J_\theta(\phi_\text{true}) \approx \alpha_k \left(\color{red}{Z_1 - \frac{g_\theta^\top g_\text{true}}{Z_2}} \right) \;.
\end{equation}
\]
</p><p>Thus, if the red term in Equation \(\eqref{eq:ddpg-bound1-derivation}\) is positive, we can conclude the approximate update improves the critic's objective more than the true update. The sign of this difference can be established as:
</p>
<p style="text-align:center">
\[
\begin{align*}
    g_\theta^\top g_\text{true} &amp;\le \|g_\theta\| \|g_\text{true}\| &amp;&amp; \text{by the Cauchy-Schwarz inequality} \\
    &amp;\le Z_1 Z_2 &amp;&amp; \text{by Equation \eqref{eq:norm-definitions}} \\ 
    &amp;\Rightarrow \quad \frac{g_\theta^\top g_\text{true}}{Z_2} \le Z_1 &amp;&amp; \text{dividing both sides by } Z_2 \;.
\end{align*}
\]
</p><p>This implies that the red term is nonnegative. Hence, for sufficiently small \(\alpha_k\),
</p>
<p style="text-align:center">
\[
\begin{equation*}
    J_\theta(\phi_\text{approx}) \ge J_\theta(\phi_\text{true}) \;.
\end{equation*}
\]
</p><p>An identical argument, with \(J_\text{true}\) replacing \(J_\theta\), shows that
</p>
<p style="text-align:center">
\[
\begin{equation*}
    J_\text{true}(\phi_\text{true}) \ge J_\text{true}(\phi_\text{approx}) \;.
\end{equation*}
\]
</p><p>These inequalities express that, under first-order updates of fixed step size, each gradient ascent step improves its own objective at least as much as the alternative step would improve that same objective.
</p>
</div></div>
<h3>Clipped Double Q-learning</h3>
<p>While both value-based methods and DPG algorithms are susceptible to overestimation bias, direct adaptations of <a href="double-q-learning.html" target=&ldquo;blank&rdquo;>mitigation strategies</a> effective in the former prove inadequate in the latter. Specifically, in the <a href="pseudocode.html" target=&ldquo;blank&rdquo;>Double DQN framework</a>, the target is constructed using the online network for action selection and the target network for value estimation. The closest analogue in an actor-critic setting uses the target critic \(Q(\theta&rsquo;)\) to evaluate the action \(\pi(s&rsquo;; \phi)\) selected by the current policy:
</p>
<p style="text-align:center">
\[
\begin{equation}\label{eq:cdq-target-ddqn-analogue}
    Y = r + \gamma Q(s&rsquo;, \pi(s&rsquo;; \phi); \theta&rsquo;) \;.
\end{equation}
\]
</p><p>In practice, however, actor-critic methods typically exhibit slow policy updates relative to the critic. Consequently, the online \(Q(\theta)\) and target \(Q(\theta&rsquo;)\) critics remain nearly identical: both are trained on rollouts from the same slowly drifting policy, and \(\theta'\) is incrementally nudged toward \(\theta\) after each step. Their estimation errors are therefore highly correlated, so the bootstrap target in Equation \(\eqref{eq:cdq-target-ddqn-analogue}\) carries no statistically independent signal; its errors mirror those of the online critic and thus cannot offset the overestimation bias.
</p>
<p>A more robust alternative, motivated by the <a href="double-q-learning.html" target=&ldquo;blank&rdquo;>original Double Q-learning formulation</a>, maintains two independent critics \(Q(\theta_1), Q(\theta_2)\) and actors \(\pi(\phi_1), \pi(\phi_2)\). Each actor is optimized with respect to its corresponding critic, while target estimates for each critic are computed using the target network of the other critic:
</p>
<p style="text-align:center">
\[
\begin{align*}
    Y_1 &amp;= r + \gamma Q \left(s&rsquo;, \pi(s&rsquo;; \phi_1); \theta_2&rsquo; \right) \label{eq:td3-doubleq-target-1} \\
    Y_2 &amp;= r + \gamma Q \left(s&rsquo;, \pi(s&rsquo;; \phi_2); \theta_1&rsquo; \right) \;. \label{eq:td3-doubleq-target-2}
\end{align*}
\]
</p><p>This scheme introduces a degree of estimator independence by decoupling action selection from value evaluation. However, the two critics are not fully independent: they are trained on the same replay buffer and their learning targets are coupled. Specifically, \(Y_1\) depends on the actor \(\pi(\phi_1)\) and the target critic \(Q(\theta_2&rsquo;)\), while \(Y_2\) depends on \(\pi(\phi_2)\) and \(Q(\cdot;\theta_1&rsquo;)\). Since \(\theta_1'\) and \(\theta_2'\) evolve based on updates influenced by \(Y_1\) and \(Y_2\), the target used to update one critic is indirectly affected by the parameters and updates of the other. Consequently, for some next state \(s'\), it may still hold that \(Q(s&rsquo;, \pi(s&rsquo;;\phi_1); \theta_2&rsquo;) &gt; Q(s&rsquo;, \pi(s&rsquo;;\phi_1); \theta_1&rsquo;)\). If \(Q(s&rsquo;, \pi(s&rsquo;;\phi_1); \theta_1&rsquo;)\) is itself an overestimate — a manifestation of the same systematic upward bias captured by the assumption in Equation \(\eqref{eq:ddpg-assumption}\), which underpins the overestimation result in Equation \(\eqref{eq:ddpg-overestimation}\) — then this interaction can amplify rather than suppress the bias.
</p>
<p>To mitigate residual overestimation, TD3 introduces <i>Clipped Double Q-learning</i>, which replaces the target with the minimum of two critic estimates. Although the conceptual exposition above assumes two actors, the practical implementation of TD3 uses a single online actor \(\pi(\phi)\) and a corresponding target actor \(\pi(\phi&rsquo;)\), which selects the action used to compute the critic target. In addition, it maintains two critic networks \(Q(\theta_1)\) and \(Q(\theta_2)\), each with its own target network \(Q(\theta_1&rsquo;)\) and \(Q(\theta_2&rsquo;)\). Each critic \(Q(\theta_i)\) is trained to regress toward the same target value:
</p>
<p style="text-align:center">
\[
\begin{equation}\label{eq:critic-target}
    Y = r + \gamma \min_{i=1,2} Q(s&rsquo;, \pi(s&rsquo;; \phi&rsquo;); \theta_i&rsquo;) \;.
\end{equation}
\]
</p><p>The \(\min\) operator bounds the more biased estimate by the lesser of the two, suppressing the upward bias introduced by function approximation and the actor's optimization of the approximate critic. While this may induce <i>underestimation</i>, such errors are preferable to overestimation as underestimated actions are unlikely to be selected and thus are not explicitly propagated through the policy update.
</p>
<h3>Target Networks and Delayed Policy Updates</h3>
<p>Clipped Double Q-learning reduces overestimation by suppressing high-variance value estimates as the \(\min\) operator favors the more conservative of two critics, limiting the impact of spurious positive errors. However, this addresses only the <i>effect</i> of variance. Variance in value estimates due to approximation errors, recursively propagated by TD updates, remains a distinct source of instability.
</p>
<p>Each TD update introduces a residual error \(\delta(s,a)\), defined as the mismatch between the critic's output \(Q(s,a;\theta)\) and its bootstrapped target. Under function approximation, the Bellman equation cannot be exactly satisfied, so these errors compound across updates. This accumulation is made explicit by expressing the Bellman equation with an error term \(\delta(s,a)\):
</p>
<p style="text-align:center">
\[
\begin{equation*}\label{eq:bellman_with_error}
    Q(s,a;\theta) = r + \gamma \mathbb{E}_{\pi, P} \left[ Q(s&rsquo;, \pi(s&rsquo;; \phi); \theta) \right] - \delta(s,a) \;.
\end{equation*}
\]
</p><p>Unrolling this recursion yields a cumulative expression for the learned value function:
</p>
<p style="text-align:center">
\[
\begin{align}
    Q(s_t,a_t;\theta) &amp;= r_t + \gamma \mathbb{E} \left[ Q(s_{t+1}, a_{t+1}; \theta) \right] - \delta_t \nonumber \\
    &amp;= r_t + \gamma \mathbb{E} \left[ r_{t+1} + \gamma \mathbb{E} \left[ Q(s_{t+2}, a_{t+2}; \theta) \right] - \delta_{t+1} \right] - \delta_t \label{eq:error_accumulation} \\
    &amp;= \mathbb{E}_{\tau \sim \pi} \left[ \sum_{i=t}^T \gamma^{i-t} (r_i - \delta_i) \right] \;. \nonumber
\end{align}
\]
</p><p>Equation \(\eqref{eq:error_accumulation}\) expresses the learned critic as the true return minus the discounted sum of TD errors. As \(\gamma \to 1\), even modest residuals can compound across updates, inflating variance and biasing the actor toward unreliable value estimates.
</p>
<p>TD3 mitigates high-variance targets by enforcing two structural constraints on the update schedule. First, target networks for both actor and critic are updated slowly via Polyak averaging: 
</p>
<p style="text-align:center">
\[
\begin{align*}
    \theta&rsquo; &amp;\leftarrow \tau \theta + (1 - \tau)\theta&rsquo; \\
    \phi&rsquo; &amp;\leftarrow \tau \phi + (1 - \tau)\phi&rsquo; \;,
\end{align*}
\]
</p><p>where with \(\tau \ll 1\). These slowly evolving targets reduce the variance of the critic's bootstrapped targets, which in turn improves the quality of the gradients passed to the actor.
</p>
<p>Second, the actor and target networks are updated less frequently than the critic. Specifically, the critic is updated every step, while the actor and all target networks (i.e., the target actor \(\pi(\phi&rsquo;)\) and both target critics \(Q(\theta_1&rsquo;), Q(\theta_2&rsquo;)\)) are updated once every \(d\) steps (typically \(d = 2\)). This two-timescale procedure ensures that the actor is optimized only when the critic has had sufficient time to reduce its estimation error. Delayed updates prevent premature policy shifts based on noisy value estimates, promoting smoother convergence and more reliable policy improvement.
</p>
<h3>Target Policy Smoothing Regularization</h3>
<p>Deterministic policies select a single action per state, making them prone to overfitting to narrow peaks in the learned Q-function. When \(Q(\theta)\) assigns disproportionately high value to one action while sharply penalizing nearby alternatives, the policy may converge to a brittle solution with poor generalization. This overfitting increases the variance of the critic's learning target (Equation \(\eqref{eq:critic-target}\)), as small perturbations to the selected action can yield large fluctuations in \(Q(\theta)\). Thus, TD3 introduces target policy smoothing, which regularizes the critic to produce smoother value estimates around the actions proposed by the target policy. Rather than evaluating only the action \(\pi(s&rsquo;;\phi&rsquo;)\), the target averages over a neighborhood around it, yielding a learning signal that is less sensitive to small perturbations. This mirrors the intuition for <a href="pseudocode.html" target=&ldquo;blank&rdquo;>SARSA</a>, where bootstrapping on the actual next action induces a form of local smoothing.
</p>
<p>The smoothed target takes the form:
</p>
<p style="text-align:center">
\[
\begin{equation}\label{eq:tps_conceptual}
    Y = r + \gamma \mathbb{E}_\epsilon \left[ Q(s&rsquo;, \pi(s&rsquo;; \phi&rsquo;) + \epsilon; \theta&rsquo;) \right] \;,
\end{equation}
\]
</p><p>where \(\epsilon\) is sampled noise and \(Q(\theta&rsquo;)\) is a target critic. This expectation attenuates the influence of sharp local maxima in the Q-function and promotes a more stable training signal for both the actor and the critic.
</p>
<p>In practice, the expectation in Equation \(\eqref{eq:tps_conceptual}\) is approximated by sampling. A small noise term \(\epsilon\) is added to the action selected by the target actor \(\pi(s&rsquo;;\phi&rsquo;)\), and the critic is updated using the Q-value at the perturbed action. The noise \(\epsilon\) is sampled from a clipped Gaussian:
</p>
<p style="text-align:center">
\[
\begin{align*}
    \tilde{a}&rsquo; &amp;= \pi(s&rsquo;; \phi&rsquo;) + \epsilon \\
    \epsilon &amp;\sim \text{clip}(\mathcal{N}(0,\sigma_a), -c, c) \;, \nonumber
\end{align*}
\]
</p><p>where \(\sigma_a\) controls the noise scale and \(c\) limits its magnitude to prevent extreme perturbations.
</p>
<p>This smoothed action \(\tilde{a}'\) is substituted into the Clipped Double Q-learning target (Equation \(\eqref{eq:critic-target}\)), yielding:
</p>
<p style="text-align:center">
\[
\begin{equation*}
    Y = r + \gamma \min_{i=1,2} Q(s&rsquo;, \tilde{a}&rsquo;; \theta_i&rsquo;) \;.
\end{equation*}
\]
</p><p>This target preserves the conservative bias of Clipped Double Q-learning while regularizing the critic against sharp discontinuities in \(Q(s,a;\theta)\). Training on perturbed actions encourages smoother value functions, reducing sensitivity to small action changes and improving the robustness of the learned policy.
</p>
<table class="imgtable"><tr><td>
<img src="static/images/td3/td3.png" alt="TD3 pseudocode" width="600px" />&nbsp;</td>
<td align="left"></td></tr></table>
<h3>References</h3>
<dl>
<dt><a href="https://arxiv.org/pdf/1802.09477" target=&ldquo;blank&rdquo;>Addressing Function Approximation Error in Actor-Critic Methods</a> (2018)</dt>
<dd><p>Scott Fujimoto, Herke van Hoof, and David Meger
</p></dd>
</dl>
<div id="footer">
<div id="footer-text">
Page generated 2025-12-04 15:37:28 PST, by <a href="https://github.com/wsshin/jemdoc_mathjax" target="blank">jemdoc+MathJax</a>.
</div>
</div>
</td>
</tr>
</table>
<!-- GoatCounter Analytics -->
<script data-goatcounter="https://mattlanders.goatcounter.com/count"
        async src="//gc.zgo.at/count.js">
</script>
</head>
<body>
