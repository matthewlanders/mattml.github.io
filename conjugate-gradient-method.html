<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta name="generator" content="jemdoc, see http://jemdoc.jaboc.net/" />
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<link rel="stylesheet" href="jemdoc.css" type="text/css" />
<title>Conjugate Gradient Method</title>
<!-- MathJax -->
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async>
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
	  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<!-- End MathJax -->
<table summary="Table for page layout." id="tlayout">
<tr valign="top">
<td id="layout-menu">
<div class="menu-category">Matthew Landers</div>
<div class="menu-item"><a href="index.html">Home</a></div>
<div class="menu-item"><a href="industry-experience.html">Experience</a></div>
<div class="menu-item"><a href="static/Matthew_Landers_CV.pdf" target="blank">CV</a></div>
<div class="menu-category">Notes</div>
<div class="menu-item"><a href="about.html"><i>About&nbsp;these&nbsp;notes</i></a></div>
<div class="menu-item"><a href="glossary.html">Glossary</a></div>
<div class="menu-item"><a href="pseudocode.html">Pseudocode</a></div>
<div class="menu-item"><a href="about-rl.html">About&nbsp;RL</a></div>
<div class="menu-item"><a href="mdp.html">MDPs</a></div>
<div class="menu-item"><a href="value-functions-and-policies.html">Value&nbsp;Func.&nbsp;&amp;&nbsp;Policies</a></div>
<div class="menu-item"><a href="dynamic-programming-for-mdps.html">DP&nbsp;for&nbsp;MDPs</a></div>
<div class="menu-item"><a href="policy-and-value-iteration-proofs.html">DP&nbsp;for&nbsp;MDPs&nbsp;Proofs</a></div>
<div class="menu-item"><a href="model-free-prediction.html">Model-Free&nbsp;Prediction</a></div>
<div class="menu-item"><a href="prediction-with-function-approximation.html">Prediction&nbsp;with&nbsp;Approx.</a></div>
<div class="menu-item"><a href="model-free-control.html">Model-Free&nbsp;Control</a></div>
<div class="menu-item"><a href="on-policy-control-with-function-approximation.html">On-Policy&nbsp;Control<br /> with&nbsp;Approximation</a></div>
<div class="menu-item"><a href="off-policy-control-with-function-approximation.html">Off-Policy&nbsp;Control<br /> with&nbsp;Approximation</a></div>
<div class="menu-item"><a href="importance-sampling.html">Importance&nbsp;Sampling</a></div>
<div class="menu-item"><a href="learnability-of-rl-objectives.html">Learnability&nbsp;of<br /> RL&nbsp;Objectives</a></div>
<div class="menu-item"><a href="the-deadly-triad.html">The&nbsp;Deadly&nbsp;Triad</a></div>
<div class="menu-item"><a href="deep-q-learning.html">Deep&nbsp;Q-Learning</a></div>
<div class="menu-item"><a href="policy-gradients.html">Policy&nbsp;Gradients</a></div>
<div class="menu-item"><a href="actor-critic.html">Actor-Critic&nbsp;Framework</a></div>
<div class="menu-item"><a href="ddpg.html">DPG&nbsp;&amp;&nbsp;DDPG</a></div>
<div class="menu-item"><a href="reparameterization-trick.html">Reparameterization&nbsp;Trick</a></div>
<div class="menu-item"><a href="sac.html">Soft&nbsp;Actor-Critic</a></div>
<div class="menu-item"><a href="grpo.html">Group&nbsp;Relative&nbsp;Policy<br /> Optimization</a></div>
<div class="menu-item"><a href="transformer.html">Transformer</a></div>
<div class="menu-item"><a href="trpo.html">TRPO</a></div>
<div class="menu-item"><a href="conjugate-gradient-method.html" class="current">Conjugate&nbsp;Gradient&nbsp;Method</a></div>
<div class="menu-item"><a href="ppo.html">PPO</a></div>
<div class="menu-item"><a href="double-q-learning.html">Double&nbsp;Q-Learning</a></div>
<div class="menu-item"><a href="td3.html">TD3</a></div>
<div class="menu-item"><a href="nn-verification.html">NN&nbsp;Verification</a></div>
<div class="menu-item"><a href="drl-verification.html">DRL&nbsp;Verification</a></div>
<div class="menu-item"><a href="alphazero.html">AlphaZero&nbsp;(chess)</a></div>
<div class="menu-item"><a href="bayes-theorem-for-probability-distributions.html">Bayes&rsquo;&nbsp;for&nbsp;Distributions</a></div>
<div class="menu-item"><a href="backpropagation.html">Backpropagation</a></div>
<div class="menu-item"><a href="off-policy-evaluation.html">Off-Policy&nbsp;Evaluation</a></div>
<div class="menu-item"><a href="constrained-mdps.html">Constrained&nbsp;MDPs</a></div>
<div class="menu-item"><a href="cpo.html">Constrained&nbsp;Policy&nbsp;<br />Optimization</a></div>
<div class="menu-item"><a href="pid-lagrangian.html">PID&nbsp;Lagrangian</a></div>
<div class="menu-item"><a href="successor-features.html">Successor&nbsp;Features</a></div>
<div class="menu-item"><a href="policy-distillation.html">Policy&nbsp;Distillation</a></div>
<div class="menu-item"><a href="kl-divergence.html">KL&nbsp;Divergence</a></div>
<div class="menu-item"><a href="implicit-q-learning.html">Implicit&nbsp;Q-Learning</a></div>
</td>
<td id="layout-content">
<div id="toptitle">
<h1>Conjugate Gradient Method</h1>
</div>
<p><i>Revised May 26, 2025</i>
</p>
<p>Consider a linear system of the form:
</p>
<p style="text-align:center">
\[
\begin{equation}\label{eq:system-of-linear-equations}
    \mathbf{Ax} = \mathbf{b} \;,
\end{equation}
\]
</p><p>where \(\mathbf{x}\) is an unknown vector, \(\mathbf{b}\) is a known vector, and \(\mathbf{A}\) is a known, square, symmetric, positive-definite matrix (i.e., for any non-zero vector \(\mathbf{z}\), \(\mathbf{z}^\top \mathbf{Az} &gt; 0\)). Although such a system admits a closed-form solution:
</p>
<p style="text-align:center">
\[
\begin{equation}\label{eq:closed-from-solution}
    \mathbf{x}^* = \mathbf{A}^{-1} \mathbf{b} \;,
\end{equation}
\]
</p><p>directly computing \(\mathbf{A}^{-1}\) is computationally expensive and often numerically unstable, especially in large, sparse settings. In practice, iterative methods are preferred, as they avoid matrix inversion altogether. Such approaches are motivated by the observation that the solution \(\mathbf{x}^*\) can equivalently be characterized as the unique vector satisfying:
</p>
<p style="text-align:center">
\[
\begin{equation}\label{eq:solution-condition}
   \mathbf{Ax}^* - \mathbf{b} = \mathbf{0} \;.
\end{equation}
\]
</p><p>This suggests the solution can be found by minimizing a differentiable function \(f : \mathbb{R}^n \to \mathbb{R}\) such that \(\nabla f(\mathbf{x}) = \mathbf{Ax} - \mathbf{b}\). More specifically, any minimizer \(\mathbf{x}^*\) must satisfy the first-order optimality condition \(\nabla f(\mathbf{x}^*) = \mathbf{0}\). Substituting the expression \(\nabla f(\mathbf{x}^*) = \mathbf{Ax}^* - \mathbf{b}\) into this condition yields Equation \(\eqref{eq:solution-condition}\). Note that while a zero gradient is a necessary condition for any local extremum or saddle point, the strict convexity of \(f(\mathbf{x})\) — guaranteed by the symmetry and positive definiteness of \(\mathbf{A}\) — ensures that \(\mathbf{x}^*\) is the unique global <i>minimum</i>. No other stationary points exist.
</p>
<p>A function satisfying \(\nabla f(\mathbf{x}) = \mathbf{Ax} - \mathbf{b}\) can be constructed in the form of a scalar quadratic function:
</p>
<p style="text-align:center">
\[
\begin{equation}\label{eq:quadratic}
    f(\mathbf{x}) = \frac{1}{2} \mathbf{x}^\top \mathbf{Ax} - \mathbf{b}^\top \mathbf{x} + c \;,
\end{equation}
\]
</p><p>where \(c\) is an arbitrary scalar constant. This corresponds to the general quadratic form \(m \mathbf{x}^\top \mathbf{Ax} + n \mathbf{b}^\top \mathbf{x} + c\) with coefficients \(m = \frac{1}{2}\) and \(n = -1\). The term “scalar quadratic function” refers to a scalar-valued function for which the highest-degree term in \(\mathbf{x}\) is quadratic.
</p>
<p>To verify that this function yields the desired gradient, we compute the derivative with respect to \(\mathbf{x}\) using matrix calculus:
</p>
<p style="text-align:center">
\[
\begin{align}
    \frac{\partial f}{\partial \mathbf{x}} &amp;= \frac{\partial}{\partial \mathbf{x}} \left( \frac{1}{2} \mathbf{x}^\top \mathbf{Ax} - \mathbf{b}^\top \mathbf{x} + c \right) \nonumber \\
    &amp;= \frac{1}{2} \mathbf{A}^\top \mathbf{x} + \frac{1}{2} \mathbf{A} \mathbf{x} - \mathbf{b} \nonumber \\
    &amp;= \mathbf{Ax} - \mathbf{b} &amp;&amp; \text{cf. Equation } \eqref{eq:system-of-linear-equations} \;. \label{eq:optimal-x-derived}
\end{align}
\]
</p><p>This equivalence — between minimizing the quadratic function \(f(\mathbf{x}) = \frac{1}{2} \mathbf{x}^\top \mathbf{Ax} - \mathbf{b}^\top \mathbf{x} + c\) and solving the linear system \(\mathbf{Ax} = \mathbf{b}\) under the assumption that \(\mathbf{A}\) is symmetric and positive-definite — enables the use of iterative optimization methods to compute \(\mathbf{x}^*\) by minimizing \(f(\mathbf{x})\), thereby avoiding the explicit matrix inversion required by Equation \(\eqref{eq:closed-from-solution}\). We consider three such approaches: gradient descent, steepest descent, and conjugate gradient descent.
</p>
<h3>Gradient Descent</h3>
<p>Gradient descent iteratively constructs a sequence of estimates that converge to the true solution. The procedure begins with an initial guess — commonly \(\mathbf{x}_0 = \mathbf{0}\) — and computes the initial <i>residual</i>, defined as:
</p>
<p style="text-align:center">
\[
\begin{equation}\label{eq:residual}
    \mathbf{r} = \mathbf{b} - \mathbf{Ax} \;.
\end{equation}
\]
</p><p>The residual quantifies how &ldquo;far&rdquo; \(\mathbf{Ax}_k\) is from \(\mathbf{b}\) (note that while the residual is a vector and thus not a scalar distance, its norm \(\|\mathbf{r}_k\|\) provides a measure of the magnitude of this discrepancy).
</p>
<p>Because the gradient of the objective function is given by \(\nabla f(\mathbf{x}) = \mathbf{Ax} - \mathbf{b}\), the residual coincides with the negative gradient:
</p>
<p style="text-align:center">
\[
\begin{equation}\label{eq:residual-gradient}
    -\nabla f(\mathbf{x}_k) = -(\mathbf{Ax}_k - \mathbf{b}) = \mathbf{b} - \mathbf{Ax}_k = \mathbf{r}_k \;.
\end{equation}
\]
</p><p>By definition, the negative gradient at a point \(\mathbf{x}\) gives the direction of steepest descent for the function at \(\mathbf{x}\). This motivates using the residual as the search direction: \(\mathbf{p}_k = \mathbf{r}_k\). At each iteration, given the current estimate \(\mathbf{x}_k\) and search direction \(\mathbf{p}_k\), the next iterate is computed by stepping along \(\mathbf{p}_k\):
</p>
<p style="text-align:center">
\[
\begin{equation}\label{eq:next-iterate}
    \mathbf{x}_{k+1} = \mathbf{x}_k + \alpha_k \mathbf{p}_k \;,
\end{equation}
\]
</p><p>where the <a href="glossary.html" target=&ldquo;blank&rdquo;>step size</a> \(\alpha_k\) is not specified by the gradient itself and is therefore treated as a hyperparameter, typically held constant across iterations (i.e., \(\alpha_k = \alpha\)).
</p>
<table class="imgtable"><tr><td>
<img src="static/images/cg-method/gradient_descent.png" alt="gradient descent" width="350px" />&nbsp;</td>
<td align="left"></td></tr></table>
<table id="caption">
<tr class="r1"><td class="c1">The blue dot indicates the initial point \(\mathbf{x}_0\), and the &ldquo;<b>x</b>&rdquo; marks the target (i.e., the minimum). Gradient descent requires 93 steps to reach the minimum in this instance, though the number of iterations depends on the choice of step size \(\alpha\).
</td></tr></table>
<h3>Steepest Descent</h3>
<p>While gradient descent requires a manually specified value for \(\alpha\), steepest descent selects the step size at each step \(k\) in a more principled way. Specifically, it chooses the value that minimizes the objective \(f\) along the search direction \(\mathbf{p}_k\):
</p>
<p style="text-align:center">
\[
\begin{equation}\label{eq:sd-alpha}
    h(\alpha) = f(\mathbf{x}_k + \alpha \mathbf{p}_k) \;.
\end{equation}
\]
</p><p>To find the minimizer, we differentiate \(h(\alpha)\) with respect to \(\alpha\) and solve for the point at which the derivative is zero:
</p>
<p style="text-align:center">
\[
\begin{equation*}
    h(\alpha) = \frac{1}{2} (\mathbf{x}_k + \alpha \mathbf{p}_k)^\top \mathbf{A} (\mathbf{x}_k + \alpha \mathbf{p}_k) - \mathbf{b}^\top (\mathbf{x}_k + \alpha \mathbf{p}_k) + c \;.
\end{equation*}
\]
</p><p>Differentiating using the chain rule yields:
</p>
<p style="text-align:center">
\[
\begin{align*}
    h&rsquo;(\alpha) &amp;= \frac{d}{d\alpha} f(\mathbf{x}_k + \alpha \mathbf{p}_k) \\
    &amp;= \nabla f(\mathbf{x}_k + \alpha \mathbf{p}_k)^\top \frac{d}{d\alpha}(\mathbf{x}_k + \alpha \mathbf{p}_k) \\
    &amp;= \nabla f(\mathbf{x}_k + \alpha \mathbf{p}_k)^\top \mathbf{p}_k \\
    &amp;= \left[ \mathbf{A}(\mathbf{x}_k + \alpha \mathbf{p}_k) - \mathbf{b} \right]^\top \mathbf{p}_k \\
    &amp;= \left[ \mathbf{A} \mathbf{x}_k + \alpha \mathbf{A} \mathbf{p}_k - \mathbf{b} \right]^\top \mathbf{p}_k \\
    &amp;= \left[ (\mathbf{A} \mathbf{x}_k - \mathbf{b}) + \alpha \mathbf{A} \mathbf{p}_k \right]^\top \mathbf{p}_k \\
    &amp;= (\mathbf{A} \mathbf{x}_k - \mathbf{b})^\top \mathbf{p}_k + \alpha (\mathbf{A} \mathbf{p}_k)^\top \mathbf{p}_k \\
    &amp;= -\mathbf{r}_k^\top \mathbf{p}_k + \alpha (\mathbf{A} \mathbf{p}_k)^\top \mathbf{p}_k &amp;&amp; \text{by Equation \(\eqref{eq:residual}\)} \\
    &amp;= -\mathbf{r}_k^\top \mathbf{p}_k + \alpha \mathbf{p}_k^\top \mathbf{A} \mathbf{p}_k &amp;&amp; \text{by the symmetry of \(\mathbf{A}\)}
\end{align*}
\]
</p><p>Setting \(h&rsquo;(\alpha_k) = 0\) and solving for \(\alpha_k\) gives:
</p>
<p style="text-align:center">
\[
\begin{align}
    -\mathbf{r}_k^\top \mathbf{p}_k + \alpha_k \mathbf{p}_k^\top \mathbf{A} \mathbf{p}_k &amp;= 0 \nonumber \\
    \alpha_k &amp;= \frac{\mathbf{r}_k^\top \mathbf{p}_k}{\mathbf{p}_k^\top \mathbf{A} \mathbf{p}_k} \;. \label{eq:step-size}
\end{align}
\]
</p><p>The next iterate is then computed using Equation \(\eqref{eq:next-iterate}\).
</p>
<p>As previously established, \(f\) has a unique global minimum due to the symmetry and positive definiteness of \(\mathbf{A}\). However, minimizing \(h(\alpha) = f(\mathbf{x}_k + \alpha \mathbf{p}_k)\) only yields the minimum of \(f\) along the line defined by \(\mathbf{p}_k\). Unless \(\mathbf{p}_k\) points directly toward the global minimizer \(\mathbf{x}^*\), the new point \(\mathbf{x}_{k+1}\) will not, in general, be the solution to the original problem. Thus, a new residual is computed using Equation \(\eqref{eq:residual}\) as:
</p>
<p style="text-align:center">
\[
\begin{equation*}
    \mathbf{r}_{k+1} = \mathbf{b} - \mathbf{A} \mathbf{x}_{k+1} \;.
\end{equation*}
\]
</p><p>This expression can be evaluated more efficiently using Equation \(\eqref{eq:next-iterate}\):
</p>
<p style="text-align:center">
\[
\begin{align}
    \mathbf{r}_{k+1} &amp;= \mathbf{b} - \mathbf{A}(\mathbf{x}_k + \alpha_k \mathbf{p}_k) &amp;&amp; \text{by Equation } \eqref{eq:next-iterate} \nonumber \\
    &amp;= (\mathbf{b} - \mathbf{A} \mathbf{x}_k) - \alpha_k \mathbf{A} \mathbf{p}_k \nonumber \\
    &amp;= \mathbf{r}_k - \alpha_k \mathbf{A} \mathbf{p}_k \;. \label{eq:next-residual}
\end{align}
\]
</p><p>This form avoids an additional matrix-vector multiplication by reusing \(\mathbf{A} \mathbf{p}_k\), which was computed when evaluating \(\alpha_k\) in Equation \(\eqref{eq:step-size}\).
</p>
<p>The next search direction is set as:
</p>
<p style="text-align:center">
\[
\begin{equation}\label{eq:next-search-direction}
    \mathbf{p}_{k+1} = \mathbf{r}_{k+1} \;,
\end{equation}
\]
</p><p>and the process repeats until convergence.
</p>
<table class="imgtable"><tr><td>
<img src="static/images/cg-method/steepest_descent.png" alt="steepest descent" width="350px" />&nbsp;</td>
<td align="left"></td></tr></table>
<table id="caption">
<tr class="r1"><td class="c1">Steepest descent, which chooses \(\alpha_k\) to exactly minimize \(f(\mathbf{x})\) along the negative gradient direction, reaches the minimum in 35 steps.
</td></tr></table>
<p>Notice in the figure above that each step is orthogonal to the previous step. This is not coincidental, it follows directly from the optimality condition along each search direction. At iteration \(k\), the algorithm moves from \(\mathbf{x}_k\) along the steepest descent direction \(\mathbf{p}_k = -\nabla f(\mathbf{x}_k)\). The line search then selects the point \(\mathbf{x}_{k+1}\) along this direction that minimizes \(f\). Crucially, because \(\mathbf{x}_{k+1}\) minimizes \(f\) along the line defined by \(\mathbf{p}_k\), the instantaneous rate of change of \(f\) at \(\mathbf{x}_{k+1}\) in the direction \(\mathbf{p}_k\) must be zero. If it were not, then continuing in that direction would further decrease the function value, contradicting the definition of \(\mathbf{x}_{k+1}\) as the minimum along that line. This condition is captured by the directional derivative, expressed as the dot product:
</p>
<p style="text-align:center">
\[
\begin{equation}\label{eq:direction-derivative}
    \nabla f(\mathbf{x}_{k+1}) \cdot \mathbf{p}_k = 0 \;.
\end{equation}
\]
</p><p>This equation is precisely the <b>mathematical definition of orthogonality</b> between the gradient vector at the new point, \(\nabla f(\mathbf{x}_{k+1})\), and the previous direction vector \(\mathbf{p}_k\) (assuming neither is the zero vector). Because the next search direction is defined as \(\mathbf{p}_{k+1} = -\nabla f(\mathbf{x}_{k+1})\), this orthogonality is inherited, ensuring that \(\mathbf{p}_{k+1}\) is orthogonal to \(\mathbf{p}_k\).
</p>
<p>Because search directions are equal to residuals (Equation \(\eqref{eq:next-search-direction}\)), this orthogonality can be confirmed algebraically by showing that the dot product of consecutive residuals satisfies \(\mathbf{r}_{k+1}^\top \mathbf{r}_k = 0\). Starting from the update rule for the residual:
</p>
<p style="text-align:center">
\[
\begin{align}
    \mathbf{r}_{k+1}^\top \mathbf{r}_k &amp;= (\mathbf{r}_k - \alpha_k \mathbf{A} \mathbf{p}_k)^\top \mathbf{r}_k &amp;&amp; \text{by Equation } \eqref{eq:next-residual} \nonumber \\
    &amp;= (\mathbf{r}_k - \alpha_k \mathbf{A} \mathbf{r}_k)^\top \mathbf{r}_k &amp;&amp; \text{by Equation } \eqref{eq:next-search-direction} \nonumber \\
    &amp;= \left( \mathbf{r}_k^\top - \alpha_k (\mathbf{A} \mathbf{r}_k)^\top \right) \mathbf{r}_k \nonumber \\
    &amp;= \left( \mathbf{r}_k^\top - \alpha_k \mathbf{r}_k^\top \mathbf{A}^\top \right) \mathbf{r}_k \nonumber \\
    &amp;= \left( \mathbf{r}_k^\top - \alpha_k \mathbf{r}_k^\top \mathbf{A} \right) \mathbf{r}_k &amp;&amp; \text{by symmetry of } \mathbf{A} \nonumber \\
    &amp;= \mathbf{r}_k^\top \mathbf{r}_k - \alpha_k \mathbf{r}_k^\top \mathbf{A} \mathbf{r}_k \nonumber \\
    &amp;= \mathbf{r}_k^\top \mathbf{r}_k - \left( \frac{\mathbf{r}_k^\top \mathbf{p}_k}{\mathbf{p}_k^\top \mathbf{A} \mathbf{p}_k} \right) \mathbf{r}_k^\top \mathbf{A} \mathbf{r}_k &amp;&amp; \text{substituting } \alpha_k \text{ from Equation } \eqref{eq:step-size} \nonumber \\
    &amp;= \mathbf{r}_k^\top \mathbf{r}_k - \left( \frac{\mathbf{r}_k^\top \mathbf{r}_k}{\mathbf{r}_k^\top \mathbf{A} \mathbf{r}_k} \right) \mathbf{r}_k^\top \mathbf{A} \mathbf{r}_k &amp;&amp; \text{since } \mathbf{p}_k = \mathbf{r}_k \nonumber \\
    &amp;= \mathbf{r}_k^\top \mathbf{r}_k - \mathbf{r}_k^\top \mathbf{r}_k \nonumber \\
    &amp;= 0 \;. \label{eq:orthogonal-residuals}
\end{align}
\]
</p><p>This confirms that \(\mathbf{r}_{k+1}\) is orthogonal to \(\mathbf{r}_k\), consistent with the geometric interpretation of steepest descent under exact line search.
</p>
<h3>The Conjugate Gradient Method</h3>
<p>The characteristic zigzagging behavior of steepest descent arises because each new search direction is orthogonal to the previous gradient, but not necessarily well-aligned with the direction of the solution. This inefficiency leads to the method repeatedly &ldquo;undoing&rdquo; progress made in earlier steps. The <i>Conjugate Gradient</i> (CG) method, by contrast, chooses search directions that are not merely orthogonal but <i>conjugate</i> — a condition that ensures progress along one direction does not interfere with progress made along others.
</p>
<h4>Conjugacy</h4>
<p>At the \(k\)‑th iteration of any descent method, the error relative to the solution \(\mathbf{x}^*\) can be defined as
</p>
<p style="text-align:center">
\[
\begin{equation}\label{eq:error}
    \mathbf{e}_k = \mathbf{x}_k - \mathbf{x}^* \;.
\end{equation}
\]
</p><p>Ideally, each step of an iterative algorithm should eliminate a distinct component of the error without undoing progress made in earlier steps. In steepest descent, overlapping directions undermine this objective. Conjugacy imposes a geometric structure that prevents reintroduction of error, ensuring that components removed in one step remain eliminated in all subsequent steps.
</p>
<p>This principle — that conjugacy prevents the reintroduction of error — can be formalized by examining orthogonality relationships between gradients. By replacing the residuals in Equation \(\eqref{eq:orthogonal-residuals}\) with gradients (justified by Equation \(\eqref{eq:residual-gradient}\)), gives the Euclidean orthogonality condition \(\mathbf{g}_k^\top \mathbf{g}_{k+1}=0\). Substituting \(\mathbf{g}_{k+1}= \mathbf{Ax}_{k+1} - \mathbf{b}\) (by Equation \(\eqref{eq:optimal-x-derived}\)) into that orthogonality relation yields:
</p>
<p style="text-align:center">
\[
\begin{align}
    0 &amp;= \mathbf{g}_k^\top \mathbf{g}_{k+1} \nonumber \\
    &amp;= \mathbf{g}_k^\top \left( \mathbf{A} \mathbf{x}_{k+1} - \mathbf{b} \right) &amp;&amp; \text{by Equation } \nonumber \eqref{eq:optimal-x-derived} \\
    &amp;= \mathbf{g}_k^\top \mathbf{A} \left( \mathbf{x}_{k+1} - \mathbf{A}^{-1} \mathbf{b} \right) \nonumber \\
    &amp;= \mathbf{g}_k^\top \mathbf{A} \left( \mathbf{x}_{k+1} - \mathbf{x}^* \right) &amp;&amp; \text{by Equation } \eqref{eq:closed-from-solution} \nonumber \\
    &amp;= \mathbf{g}_k^\top \mathbf{A} \mathbf{e}_{k+1} &amp;&amp; \text{by Equation } \eqref{eq:error} \;. \label{eq:orthogonal-error}
\end{align}
\]
</p><p>This derivation shows that the new error \(\mathbf{e}_{k+1}\) is orthogonal to the current gradient \(\mathbf{g}_k\) under the \(A\)-inner product:
</p>
<p style="text-align:center">
\[
\begin{equation*}
    \langle \mathbf{u}, \mathbf{v} \rangle_A = \mathbf{u}^\top \mathbf{A} \mathbf{v} \;.
\end{equation*}
\]
</p><p>Orthogonality under this metric, called <i>conjugacy</i>, is the central geometric property underpinning the CG method.
</p>
<p>The result in Equation \(\eqref{eq:orthogonal-error}\) motivates constructing the next search direction \(\mathbf{p}_{k+1}\) to align with the new gradient \(\mathbf{g}_{k+1}\) (to reduce remaining error), while being \(A\)-orthogonal to previous search directions \(\mathbf{p}_i\) for \(i \le k\) (to avoid reintroducing eliminated error components). Geometrically, \(\mathbf{p}_{k+1}\) should lie in the span:
</p>
<p style="text-align:center">
\[
\begin{equation*}
    \mathbf{p}_{k+1} \; \in \; \mathrm{span}\{\mathbf{g}_{k+1}, \mathbf{p}_k\} \;,
\end{equation*}
\]
</p><p>with the unique choice satisfying the conjugacy condition:
</p>
<p style="text-align:center">
\[
\begin{equation*}
    \mathbf{p}_{k+1}^\top \mathbf{A} \mathbf{p}_k = 0 \;.
\end{equation*}
\]
</p><p>Here, the span comprises all vectors of the form \(\alpha \mathbf{g}_{k+1} + \beta \mathbf{p}_k\) for scalars \(\alpha, \beta \in \mathbb{R}\).
</p>
<p>CG realizes this structure by setting:
</p>
<p style="text-align:center">
\[
\begin{align}
    \mathbf{p}_0 &amp;= \mathbf{r}_0 \label{eq:initial-direction} \\
    \mathbf{p}_{k+1} &amp;= \mathbf{r}_{k+1} + \beta_k \mathbf{p}_k \;, \label{eq:next-direction}
\end{align}
\]
</p><p>where the scalar \(\beta_k\) is chosen to enforce \(A\)-orthogonality between consecutive directions. Imposing the conjugacy condition yields:
</p>
<p style="text-align:center">
\[
\begin{align}
    (\mathbf{r}_{k+1} + \beta_k \mathbf{p}_k)^\top \mathbf{A} \mathbf{p}_k &amp;= 0 \nonumber \\
    \mathbf{r}_{k+1}^\top \mathbf{A} \mathbf{p}_k + \beta_k \mathbf{p}_k^\top \mathbf{A} \mathbf{p}_k &amp;= 0 \nonumber \\
    \beta_k &amp;= -\frac{\mathbf{r}_{k+1}^\top \mathbf{A} \mathbf{p}_k}{\mathbf{p}_k^\top \mathbf{A} \mathbf{p}_k} \;. \label{eq:beta}
\end{align}
\]
</p><h4>Computing the step size \(\alpha\)</h4>
<p>As in steepest descent (Equation \(\eqref{eq:sd-alpha}\)), the optimal step size \(\alpha_k\) is chosen to minimize the function:
</p>
<p style="text-align:center">
\[
\begin{equation*}
    h(\alpha) = f(\mathbf{x}_k + \alpha \mathbf{p}_k) \;,
\end{equation*}
\]
</p><p>thereby ensuring exact minimization of \(f\) along \(\mathbf{p}_k\) at each iteration. Applying the same derivation that produced Equation \(\eqref{eq:step-size}\), \(\alpha_k\) is computed as:
</p>
<p style="text-align:center">
\[
\begin{equation}
    \alpha_k = \frac{-\mathbf{g}_k^\top \mathbf{p}_k}{\mathbf{p}_k^\top \mathbf{A} \mathbf{p}_k} \;. \label{eq:optimal-alpha}
\end{equation}
\]
</p><table class="imgtable"><tr><td>
<img src="static/images/cg-method/conjugate_gradient.png" alt="conjugate gradient descent" width="350px" />&nbsp;</td>
<td align="left"></td></tr></table>
<table id="caption">
<tr class="r1"><td class="c1">By aligning its search directions with the geometry induced by \(\mathbf{A}\), CG reaches the minimum in just two steps — one per dimension — as each direction eliminates error in a distinct \(A\)-orthogonal component.
</td></tr></table>
<h3>Proving Global Conjugacy by Induction</h3>
<p>Having established the procedure for computing \(\mathbf{p}\), \(\alpha\), and \(\beta\), it remains to show that the choice of \(\beta\) in Equation \(\eqref{eq:beta}\) guarantees conjugacy with <b>all</b> preceding directions. We  will prove by induction on \(k\), the number of generated directions, that the set \(\{\mathbf{p}_0, \mathbf{p}_1, \dots, \mathbf{p}_{k-1}\}\) is A-conjugate for any \(k \ge 1\).
</p>
<p>More formally, let \(P(k)\) denote the statement:
</p>
<p style="text-align:center">
\[
\begin{equation}\label{eq:global-conjugacy-statement}
    \mathbf{p}_i^\top \mathbf{A} \mathbf{p}_j = 0 \qquad \text{for all } i \ne j, \text{ where } 0 \le i, j &lt; k \;.
\end{equation}
\]
</p><p>We will show that \(P(k)\) holds for all \(k \ge 1\). This A-conjugacy ensures that each search direction preserves orthogonality with respect to the \(\mathbf{A}\)-inner product, thereby maintaining the progress of prior steps.
</p>
<h4>Base Cases</h4>
<p>For \(k = 1\), the set \(\{\mathbf{p}_0\}\) contains only one direction, so no distinct indices \(i \ne j\) exist and the condition in Equation \(\eqref{eq:global-conjugacy-statement}\) is vacuously satisfied. Thus, \(P(1)\) holds. For \(k = 2\), \(P(2)\) requires that \(\mathbf{p}_1^\top \mathbf{A} \mathbf{p}_0 = 0\) for the set \(\{\mathbf{p}_0, \mathbf{p}_1\}\). By construction, \(\mathbf{p}_1 = \mathbf{r}_1 + \beta_0 \mathbf{p}_0\) (Equation \(\eqref{eq:next-direction}\)), with \(\beta_0\) chosen to enforce:
</p>
<p style="text-align:center">
\[
\begin{equation*}
    (\mathbf{r}_1 + \beta_0 \mathbf{p}_0)^\top \mathbf{A} \mathbf{p}_0 = 0 \;,
\end{equation*}
\]
</p><p>via Equation \(\eqref{eq:beta}\). It therefore follows directly that \(\mathbf{p}_1^\top \mathbf{A} \mathbf{p}_0 = 0\), confirming \(P(2)\).
</p>
<h4>Inductive Hypothesis</h4>
<p>Assume that \(P(K)\) holds for some integer \(K \ge 1\).
</p>
<h4>Inductive Step</h4>
<p>Assuming the inductive hypothesis \(P(K)\) is true, it remains to show that \(P(K+1)\) also holds. The property \(P(K+1)\) asserts that the set \(\{\mathbf{p}_0, \mathbf{p}_1, \dots, \mathbf{p}_K\}\) is A-conjugate, as defined by Equation \(\eqref{eq:global-conjugacy-statement}\) with \(k=K+1\). The inductive hypothesis ensures that all pairs of distinct vectors in the subset \(\{\mathbf{p}_0, \dots, \mathbf{p}_{K-1}\}\) are A-conjugate. Thus, establishing \(P(K+1)\) reduces to verifying that the newest direction, \(\mathbf{p}_K\), is A-conjugate to each preceding direction \(\mathbf{p}_0, \dots, \mathbf{p}_{K-1}\). Specifically, it must be shown that
</p>
<p style="text-align:center">
\[
\begin{equation*}
    \mathbf{p}_K^\top \mathbf{A} \mathbf{p}_j = 0 \quad \text{for all} \quad 0 \le j &lt; K \;.
\end{equation*}
\]
</p><p>A-conjugacy with the most recent direction, \(\mathbf{p}_{K-1}\), follows directly from the definition \(\mathbf{p}_K = \mathbf{r}_K + \beta_{K-1} \mathbf{p}_{K-1}\), where \(\beta_{K-1}\) is chosen to enforce \(\mathbf{p}_K^\top \mathbf{A} \mathbf{p}_{K-1} = 0\) (Equation \(\eqref{eq:beta}\)). This mirrors the verification in \(P(2)\).
</p>
<p>Next, A-conjugacy for \(\mathbf{p}_K\) with respect to all earlier directions \(\mathbf{p}_j\), where \(j &lt; K-1\), must be established. Expanding \(\mathbf{p}_K = \mathbf{r}_K + \beta_{K-1} \mathbf{p}_{K-1}\) gives
</p>
<p style="text-align:center">
\[
\begin{align*}
    \mathbf{p}_K^\top \mathbf{A} \mathbf{p}_j &amp;= (\mathbf{r}_K + \beta_{K-1} \mathbf{p}_{K-1})^\top \mathbf{A} \mathbf{p}_j \\
    &amp;= \color{blue}{\mathbf{r}_K^\top \mathbf{A} \mathbf{p}_j} + \color{red}{\beta_{K-1} (\mathbf{p}_{K-1}^\top \mathbf{A} \mathbf{p}_j)} \;.
\end{align*}
\]
</p><p>Because \(j &lt; K-1\), the directions \(\mathbf{p}_{K-1}\) and \(\mathbf{p}_j\) are distinct elements of \(\{\mathbf{p}_0, \dots, \mathbf{p}_{K-1}\}\). By the inductive hypothesis \(P(K)\), this set is A-conjugate, so \(\mathbf{p}_{K-1}^\top \mathbf{A} \mathbf{p}_j = 0\) and the red term \(\color{red}{\beta_{K-1} (\mathbf{p}_{K-1}^\top \mathbf{A} \mathbf{p}_j)}\) vanishes.
</p>
<p>Demonstrating A-conjugacy with all prior directions thus simplifies to proving that the blue term, \(\color{blue}{\mathbf{r}_K^\top \mathbf{A} \mathbf{p}_j}\), is zero. To evaluate this term, an explicit expression for \(\mathbf{A}\mathbf{p}_j\) is required. Rearranging the residual update \(\mathbf{r}_{j+1} = \mathbf{r}_j - \alpha_j \mathbf{A} \mathbf{p}_j\) (Equation \(\eqref{eq:next-residual}\)) yields:
</p>
<p style="text-align:center">
\[
\begin{equation*}
    \mathbf{A} \mathbf{p}_j = \frac{1}{\alpha_j}(\mathbf{r}_j - \mathbf{r}_{j+1}) \;.
\end{equation*}
\]
</p><p>Substituting into \(\color{blue}{\mathbf{r}_K^\top \mathbf{A} \mathbf{p}_j}\) gives
</p>
<p style="text-align:center">
\[
\begin{align}
    \mathbf{r}_K^\top \mathbf{A} \mathbf{p}_j &amp;= \mathbf{r}_K^\top \left( \frac{1}{\alpha_j}(\mathbf{r}_j - \mathbf{r}_{j+1}) \right) \nonumber \\
    &amp;= \frac{1}{\alpha_j} (\mathbf{r}_K^\top \mathbf{r}_j - \mathbf{r}_K^\top \mathbf{r}_{j+1}) \;. \label{eq:inductive-task}
\end{align}
\]
</p><p>This expression is zero if the current residual \(\mathbf{r}_K\) is orthogonal to all previous residuals; that is, if \(\mathbf{r}_K^\top \mathbf{r}_j = 0\) and \(\mathbf{r}_K^\top \mathbf{r}_{j+1} = 0\). It therefore remains to establish the general property \(\mathbf{r}_K^\top \mathbf{r}_m = 0\) for all \(m &lt; K\).
</p>
<p>To demonstrate residual orthogonality, \(\mathbf{r}_K^\top \mathbf{r}_m = 0\) for \(m &lt; K\), first note that any previous residual \(\mathbf{r}_m\) can be written as a linear combination of the search directions up to \(\mathbf{p}_m\). Specifically, for the base case \(m = 0\), Equation \(\eqref{eq:initial-direction}\) gives \(\mathbf{p}_0 = \mathbf{r}_0\), so \(\mathbf{r}_0 = 1 \cdot \mathbf{p}_0\), and thus \(\mathbf{r}_0 \in \mathrm{span}\{\mathbf{p}_0\}\). For \(m &gt; 0\), Equation \(\eqref{eq:next-direction}\) gives:
</p>
<p style="text-align:center">
\[
\begin{align*}
    \mathbf{p}_m &amp;= \mathbf{r}_m + \beta_{m-1} \mathbf{p}_{m-1} \\
    \mathbf{r}_m &amp;= \mathbf{p}_m - \beta_{m-1} \mathbf{p}_{m-1} \;.
\end{align*}
\]
</p><p>Because \(\mathbf{p}_m, \mathbf{p}_{m-1} \in \{\mathbf{p}_0, \dots, \mathbf{p}_m\}\), it follows that \(\mathbf{r}_m\) can be written as a linear combination of all vectors in \(\{\mathbf{p}_0, \dots, \mathbf{p}_m\}\) by assigning zero coefficients to all vectors other than \(\mathbf{p}_m\) and \(\mathbf{p}_{m-1}\):
</p>
<p style="text-align:center">
\[
\begin{equation*}
    \mathbf{r}_m = \sum_{i=0}^{m} c_i \mathbf{p}_i \;,
\end{equation*}
\]
</p><p>for some coefficients \(c_i\).
</p>
<p>The inner product \(\mathbf{r}_K^\top \mathbf{r}_m\) for \(m &lt; K\) can thus be written as:
</p>
<p style="text-align:center">
\[
\begin{equation}\label{eq:residual-sum}
    \mathbf{r}_K^\top \mathbf{r}_m = \mathbf{r}_K^\top \left( \sum_{i=0}^{m} c_i \mathbf{p}_i \right) = \sum_{i=0}^{m} c_i (\mathbf{r}_K^\top \mathbf{p}_i) \;.
\end{equation}
\]
</p><p>This sum is zero if \(\mathbf{r}_K^\top \mathbf{p}_i = 0\) for all \(i \le m &lt; K\). It is therefore necessary to show that the current residual \(\mathbf{r}_K\) is orthogonal to all previous search directions \(\mathbf{p}_i\) for \(i &lt; K\).
</p>
<p>To prove \(\mathbf{r}_K^\top \mathbf{p}_i = 0\) for \(i &lt; K\), consider two cases for the index \(i\). For \(i = K-1\), the orthogonality \(\mathbf{r}_K^\top \mathbf{p}_{K-1} = 0\) follows from the exact line search at iteration \(K-1\), which ensures the gradient at \(\mathbf{x}_K\) is orthogonal to the search direction \(\mathbf{p}_{K-1}\). Specifically, for the step from \(\mathbf{x}_{K-1}\) to \(\mathbf{x}_K\) along \(\mathbf{p}_{K-1}\),
</p>
<p style="text-align:center">
\[
\begin{align*}
    \nabla f(\mathbf{x}_K)^\top \mathbf{p}_{K-1} &amp;= 0 &amp;&amp; \text{by Equation } \eqref{eq:direction-derivative} \\
    \mathbf{g}_K^\top \mathbf{p}_{K-1} &amp;= 0 &amp;&amp; \text{where } \mathbf{g}_K = \nabla f(\mathbf{x}_K) \\
    \mathbf{r}_K^\top \mathbf{p}_{K-1} &amp;= 0 &amp;&amp; \text{by Equation } \eqref{eq:residual-gradient} \text{ (since } \mathbf{r}_K = -\mathbf{g}_K \text{)}\;.
\end{align*}
\]
</p><p>Thus, \(\mathbf{r}_K\) is orthogonal to the most recent prior direction \(\mathbf{p}_{K-1}\).
</p>
<p>For the earlier directions (\(i &lt; K-1\)), we rely on gradient recurrence. Because \(\mathbf{r}_m = -\mathbf{g}_m\), the residual update \(\mathbf{r}_{m+1} = \mathbf{r}_m - \alpha_m \mathbf{A}\mathbf{p}_m\) (Equation \(\eqref{eq:next-residual}\)) yields:
</p>
<p style="text-align:center">
\[
\begin{equation*}
    \mathbf{g}_K = \mathbf{g}_{K-1} + \alpha_{K-1} \mathbf{A} \mathbf{p}_{K-1} \;.
\end{equation*}
\]
</p><p>Taking the inner product with \(\mathbf{p}_i\) for \(i &lt; K-1\) gives:
</p>
<p style="text-align:center">
\[
\begin{align*}
    \mathbf{g}_K^\top \mathbf{p}_i &amp;= (\mathbf{g}_{K-1} + \alpha_{K-1} \mathbf{A} \mathbf{p}_{K-1})^\top \mathbf{p}_i \\
    &amp;= \mathbf{g}_{K-1}^\top \mathbf{p}_i + \alpha_{K-1} (\color{red}{\mathbf{p}_{K-1}^\top \mathbf{A} \mathbf{p}_i}) \;.
\end{align*}
\]
</p><p>By the inductive hypothesis \(P(K)\) (Equation \(\eqref{eq:global-conjugacy-statement}\)), the term \(\color{red}{\mathbf{p}_{K-1}^\top \mathbf{A} \mathbf{p}_i} = 0\) for \(i &lt; K-1\). Thus, the recurrence reduces to \(\mathbf{g}_K^\top \mathbf{p}_i = \mathbf{g}_{K-1}^\top \mathbf{p}_i\). Repeatedly applying this relationship gives:
</p>
<p style="text-align:center">
\[
\begin{equation*}
    \mathbf{g}_K^\top \mathbf{p}_i = \mathbf{g}_{K-1}^\top \mathbf{p}_i = \dots = \color{blue}{\mathbf{g}_{i+1}^\top \mathbf{p}_i} \;.
\end{equation*}
\]
</p><p>The final term, \(\color{blue}{\mathbf{g}_{i+1}^\top \mathbf{p}_i}\), vanishes due to the exact line search at iteration \(i\), which ensures \(\nabla f(\mathbf{x}_{i+1})\) is orthogonal to \(\mathbf{p}_i\) (Equation \(\eqref{eq:direction-derivative}\)).
</p>
<p>Combining both cases (\(i = K-1\) and \(i &lt; K-1\)), it is now established that the current residual is orthogonal to all previous search directions:
</p>
<p style="text-align:center">
\[
\begin{equation}\label{eq:residual-direction-orthogonality-established-final}
    \mathbf{r}_K^\top \mathbf{p}_i = 0 \quad \text{for all } i &lt; K \;.
\end{equation}
\]
</p><p>Returning to Equation \(\eqref{eq:residual-sum}\), since \(i \le m &lt; K\), Equation \(\eqref{eq:residual-direction-orthogonality-established-final}\) guarantees that each term \(\mathbf{r}_K^\top \mathbf{p}_i\) in the sum is zero. Thus, the entire sum vanishes, establishing the orthogonality of residuals:
</p>
<p style="text-align:center">
\[
\begin{equation}\label{eq:residual-orthogonality-established-final}
    \mathbf{r}_K^\top \mathbf{r}_m = 0 \quad \text{for all } m &lt; K \;.
\end{equation}
\]
</p><p>With this crucial result, Equation \(\eqref{eq:inductive-task}\) can finally be evaluated:
</p>
<p style="text-align:center">
\[
\begin{equation*}
    \mathbf{r}_K^\top \mathbf{A} \mathbf{p}_j = \frac{1}{\alpha_j} (\mathbf{r}_K^\top \mathbf{r}_j - \mathbf{r}_K^\top \mathbf{r}_{j+1}) \;.
\end{equation*}
\]
</p><p>Because \(j &lt; K-1\), it must be true that \(j &lt; K\) and \(j+1 &lt; K\). By the established residual orthogonality (Equation \(\eqref{eq:residual-orthogonality-established-final}\)), \(\mathbf{r}_K^\top \mathbf{r}_j = 0\) and \(\mathbf{r}_K^\top \mathbf{r}_{j+1} = 0\), so \(\mathbf{r}_K^\top \mathbf{A} \mathbf{p}_j = 0\). Thus, the first term in the expression for \(\mathbf{p}_K^\top \mathbf{A} \mathbf{p}_j\) vanishes, and for \(j &lt; K-1\),
\(\mathbf{p}_K^\top \mathbf{A} \mathbf{p}_j = 0\).
</p>
<p>Given \(\mathbf{p}_K^\top \mathbf{A} \mathbf{p}_j = 0\) has been shown for both \(j = K-1\) and all \(j &lt; K-1\), it follows that \(\mathbf{p}_K\) is A-conjugate to all preceding directions \(\mathbf{p}_0, \dots, \mathbf{p}_{K-1}\). Therefore, \(P(K+1)\) holds.
</p>
<h3>Practical implementation</h3>
<p>The expression for \(\alpha_k\) in Equation \(\eqref{eq:optimal-alpha}\) involves the inner product between the gradient \(\mathbf{g}_k\) and the search direction \(\mathbf{p}_k\):
</p>
<p style="text-align:center">
\[
\begin{equation*}
    \alpha_k = \frac{-\mathbf{g}_k^\top \mathbf{p}_k}{\mathbf{p}_k^\top \mathbf{A} \mathbf{p}_k} \;.
\end{equation*}
\]
</p><p>This computation can be simplified by rewriting the numerator. First, observe that:
</p>
<p style="text-align:center">
\[
\begin{align*}
    -\mathbf{g}_k^\top \mathbf{p}_k &amp;= \mathbf{r}_k^\top \mathbf{p}_k &amp;&amp; \text{by definition of the residual} \\
    &amp;= \mathbf{r}_k^\top (\mathbf{r}_k + \beta_{k-1} \mathbf{p}_{k-1}) &amp;&amp; \text{by Equation } \eqref{eq:next-direction} \\
    &amp;= \mathbf{r}_k^\top \mathbf{r}_k + \beta_{k-1} \mathbf{r}_k^\top \mathbf{p}_{k-1} \\
    &amp;= \mathbf{r}_k^\top \mathbf{r}_k &amp;&amp; \text{since } \mathbf{r}_k^\top \mathbf{p}_{k-1} = 0 \text{ by Equation } \eqref{eq:residual-direction-orthogonality-established-final}
\end{align*}
\]
</p><p>Substituting this into Equation \(\eqref{eq:optimal-alpha}\) yields the simplified expression:
</p>
<p style="text-align:center">
\[
\begin{equation}\label{eq:simplified-alpha}
    \alpha_k = \frac{\mathbf{r}_k^\top \mathbf{r}_k}{\mathbf{p}_k^\top \mathbf{A} \mathbf{p}_k} \;.
\end{equation}
\]
</p><p>This form is preferred in practice, as the numerator \(\mathbf{r}_k^\top \mathbf{r}_k\) is already computed during the update for \(\beta_k\) and can be reused. More specifically, the expression for \(\beta_k\) in Equation \(\eqref{eq:beta}\) can be similarly simplified using the residual update formula \(\mathbf{r}_{k+1} = \mathbf{r}_k - \alpha_k \mathbf{A} \mathbf{p}_k\) (Equation \(\eqref{eq:next-residual}\)) via Equation \(\eqref{eq:inductive-task}\) and the orthogonality property \(\mathbf{r}_{k+1}^\top \mathbf{r}_k = 0\) (Equation \(\eqref{eq:residual-orthogonality-established-final}\)):
</p>
<p style="text-align:center">
\[
\begin{align*}
    \beta_k &amp;= -\frac{\mathbf{r}_{k+1}^\top \mathbf{A} \mathbf{p}_k}{\mathbf{p}_k^\top \mathbf{A} \mathbf{p}_k} \\
    &amp;= - \frac{\mathbf{r}_{k+1}^\top (\mathbf{r}_k - \mathbf{r}_{k+1}) / \alpha_k}{\mathbf{p}_k^\top \mathbf{A} \mathbf{p}_k} &amp;&amp; \text{by Equation } \eqref{eq:inductive-task} \\
    &amp;= - \frac{\mathbf{r}_{k+1}^\top \mathbf{r}_k / \alpha_k - \mathbf{r}_{k+1}^\top \mathbf{r}_{k+1} / \alpha_k}{\mathbf{p}_k^\top \mathbf{A} \mathbf{p}_k} \\
    &amp;= \frac{\mathbf{r}_{k+1}^\top \mathbf{r}_{k+1} / \alpha_k}{\mathbf{p}_k^\top \mathbf{A} \mathbf{p}_k} &amp;&amp; \text{by Equation } \eqref{eq:residual-orthogonality-established-final} \\
    &amp;= \frac{\mathbf{r}_{k+1}^\top \mathbf{r}_{k+1} / \left(\frac{\mathbf{r}_k^\top \mathbf{r}_k}{\mathbf{p}_k^\top \mathbf{A} \mathbf{p}_k} \right)}{\mathbf{p}_k^\top \mathbf{A} \mathbf{p}_k} &amp;&amp; \text{by Equation } \eqref{eq:simplified-alpha} \\
    &amp;= \frac{\mathbf{r}_{k+1}^\top \mathbf{r}_{k+1} \cdot \mathbf{p}_k^\top \mathbf{A} \mathbf{p}_k}{\mathbf{r}_k^\top \mathbf{r}_k \cdot \mathbf{p}_k^\top \mathbf{A} \mathbf{p}_k} \\
    &amp;= \frac{\mathbf{r}_{k+1}^\top \mathbf{r}_{k+1}}{\mathbf{r}_k^\top \mathbf{r}_k} \;.
\end{align*}
\]
</p><p>This final form is computationally efficient: it requires only inner products of residuals, avoiding any additional matrix-vector multiplications.
</p>
<p>In summary, CG proceeds by first moving in the direction of steepest descent (\(\mathbf{p}_0 = \mathbf{r}_0\)). At each iteration \(k\), it selects a step size \(\alpha_k\) to exactly minimize the objective along the current search direction \(\mathbf{p}_k\). The new residual \(\mathbf{r}_{k+1}\) is then computed using the previous residual and the matrix-vector product \(\mathbf{A}\mathbf{p}_k\). A new search direction \(\mathbf{p}_{k+1}\) is formed by combining the new residual \(\mathbf{r}_{k+1}\) with a scaled contribution from \(\mathbf{p}_k\), where the scaling factor \(\beta_k\) is chosen to ensure \(A\)-conjugacy between \(\mathbf{p}_{k+1}\) and \(\mathbf{p}_k\). This construction recursively maintains \(A\)-conjugacy with <b>all</b> previous directions. Global \(A\)-conjugacy ensures that the search directions are independent relative to the geometry induced by \(\mathbf{A}\), allowing the algorithm to eliminate error components sequentially without interference, thereby minimizing the objective (Equation \(\eqref{eq:quadratic}\)) efficiently.
</p>
<table class="imgtable"><tr><td>
<img src="static/images/cg-method/pseudocode.png" alt="conjugate gradient pseudocode" width="600px" />&nbsp;</td>
<td align="left"></td></tr></table>
<h3>References</h3>
<dl>
<dt><a href="https://www.cs.cmu.edu/~quake-papers/painless-conjugate-gradient.pdf" target=&ldquo;blank&rdquo;>An Introduction to the Conjugate Gradient Method Without the Agonizing Pain</a> (1994)</dt>
<dd><p>Jonathan Richard Shewchuk
</p></dd>
</dl>
<dl>
<dt><a href="https://gregorygundersen.com/blog/2022/03/20/conjugate-gradient-descent/" target=&ldquo;blank&rdquo;>Conjugate Gradient Descent</a> (2022)</dt>
<dd><p>Gregory Gundersen
</p></dd>
</dl>
<dl>
<dt><a href="https://gregorygundersen.com/blog/2022/02/27/positive-definite" target=&ldquo;blank&rdquo;>Understanding Positive Definite Matrices</a> (2022)</dt>
<dd><p>Gregory Gundersen
</p></dd>
</dl>
<div id="footer">
<div id="footer-text">
Page generated 2025-12-04 15:37:28 PST, by <a href="https://github.com/wsshin/jemdoc_mathjax" target="blank">jemdoc+MathJax</a>.
</div>
</div>
</td>
</tr>
</table>
<!-- GoatCounter Analytics -->
<script data-goatcounter="https://mattlanders.goatcounter.com/count"
        async src="//gc.zgo.at/count.js">
</script>
</head>
<body>
